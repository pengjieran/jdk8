<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta content="text/html; charset=us-ascii" http-equiv="Content-Type"/>
<meta content="text/css" http-equiv="Content-Style-Type"/>
<meta content="text/javascript" http-equiv="Content-Script-Type"/>
<title>Submitting Bug Reports</title>
<meta content="Oracle DARB XHTML Converter (Mode = document) - Version 1.0.23 Build 1" name="generator"/>
<meta content="2014-02-20T13:52:55Z" name="date"/>
<meta content="This chapter provides guidance on how to submit a bug report. It includes suggestions about what to try before submitting a report and what data to collect for the report." name="description"/>
<meta content="noarchive" name="robots"/>
<meta content="Submitting Bug Reports" name="doctitle"/>
<meta content="Release 8" name="relnum"/>
<meta content="E38388-01" name="partnum"/>




<link rel="stylesheet" type="text/css" href="../../../technotes/css/guide.css" />
</head>
<body>
<!-- STATIC HEADER -->

<!-- header start -->
<div id="javaseheader">
<div id="javaseheaderlogo">
<img src="../../../images/javalogo.gif"
alt="Java logo" />
</div>
<div id="javaseheaderindex">

<a href=
"../../../index.html">Documentation Contents</a>
</div>
<div class="clear"></div>
</div>

<!-- header end -->


<b>Java Platform, Standard Edition HotSpot Virtual Machine Troubleshooting Guide</b><br/>

<a href="toc.html">
                Contents</a>&nbsp;&nbsp;&nbsp;<a href="signals.html">
                Previous</a>&nbsp;&nbsp;&nbsp;<a href="envvars.html">
                Next</a><hr/><a id="submitting_bug_reports" name="submitting_bug_reports"/>
<h1><span>7</span> Submitting Bug Reports</h1>
<p>This chapter provides guidance on how to submit a bug report. It includes suggestions about what to try before submitting a report and what data to collect for the report.</p>
<p>This chapter contains the following sections:</p>
<ul>
<li>
<p><a href="#A998787">"Checking for Existing Fixes in Update Releases"</a></p>
</li>
<li>
<p><a href="#A998824">"Preparing to Submit a Bug Report"</a></p>
</li>
<li>
<p><a href="#A998988">"Collecting Data for a Bug Report"</a></p>
</li>
<li>
<p><a href="#collecting_core_dumps">"Collecting Core Dumps"</a></p>
</li>
</ul>
<a id="A998787" name="A998787"/>
<div>
<h2>Checking for Existing Fixes in Update Releases</h2>
<p>The current platform is Java SE 8. Regularly scheduled updates to this release contain fixes for a set of critical bugs identified since the initial release of the platform. When an update release becomes available, it becomes the default download at the <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Java SE Downloads site</a>.</p>
<p>The download site includes release notes that list the bug fixes in the release. Each bug in the list is linked to the bug description in the bug database. The release notes also include the list of fixes in previous update releases. If you encounter an issue, or suspect a bug, then, as an early step in the diagnosis, check the list of fixes that are available in the most recent update release.</p>
<p>Sometimes it is not obvious if an issue is a duplicate of a bug that is already fixed. Therefore, where possible, test with the latest update release to see if the problem persists.</p>
</div>

<a id="A998824" name="A998824"/>
<div>
<h2>Preparing to Submit a Bug Report</h2>
<p>Before submitting a bug report, consider the following recommendations:</p>
<ul>
<li>
<p>Collect as much relevant data as possible. For example, generate a thread-dump in the case of a deadlock, or locate the core file (where applicable) and hs_err file in the case of a crash. In all cases it is important to document the environment and the actions performed just before the problem is encountered.</p>
</li>
<li>
<p>Where applicable, try to restore the original state and reproduce the problem using the documented steps. This helps to determine if the problem is reproducible or an intermittent issue.</p>
</li>
<li>
<p>If the issue is reproducible, try to narrow down the problem. In some cases, a bug can be demonstrated with a small standalone test case. Bugs that are demonstrated by small test cases will typically be easy to diagnose when compared to test cases that consist of a large complex application.</p>
</li>
<li>
<p>Search the bug database to see if this bug or a similar bug has been reported. If the bug has already been reported, the bug report might have further information, such as the following:</p>
<ul>
<li>
<p>If the bug has already been fixed, the release in which it was fixed.</p>
</li>
<li>
<p>A workaround for the problem.</p>
</li>
<li>
<p>Comments in the evaluation that explain, in further detail, the circumstances that cause the bug to arise.</p>
</li>
</ul>
<p>The bug database is located at <code><a href="http://bugs.java.com/bugdatabase/index.jsp">http://bugs.java.com/bugdatabase/index.jsp</a></code>.</p>
</li>
<li>
<p>If you conclude that the bug has not already been reported, submit a new bug.</p>
</li>
</ul>
<p>Before submitting a bug, verify that the environment where the problem arises is a supported configuration. See the <a href="http://www.oracle.com/technetwork/java/javase/config-417990.html">Supported System Configurations site</a>.</p>
<p>In addition to the system configurations, check the list of supported locales. See the <a href="http://www.oracle.com/technetwork/java/javase/java8locales-2095355.html">Supported Locales web page</a>.</p>
<p>In the case of the Solaris Operating System, check the recommended patch cluster for the operating system release to ensure that the recommended patches are installed.</p>
</div>

<a id="A998988" name="A998988"/>
<div>
<h2>Collecting Data for a Bug Report</h2>
<p>In general it is recommended to collect as much relevant data as possible when you create a bug report or submit a support call. This section suggests the data to collect and, where applicable, it provides recommendations for the commands or general procedure for obtaining the data.</p>
<p>The following sections provide information about data that can be collected prior to submitting a bug report:</p>
<ul>
<li>
<p><a href="#hardware_details">"Hardware Details"</a></p>
</li>
<li>
<p><a href="#operating_system">"Operating System"</a></p>
</li>
<li>
<p><a href="#java_se_version_string">"Java SE Version"</a></p>
</li>
<li>
<p><a href="#command_line_bug_reports">"Command-Line Options"</a></p>
</li>
<li>
<p><a href="#env_vars_bug_reports">"Environment Variables"</a></p>
</li>
<li>
<p><a href="#fatal_error_log_bug_report">"Fatal Error Log"</a></p>
</li>
<li>
<p><a href="#core_crash_dump">"Core or Crash Dump"</a></p>
</li>
<li>
<p><a href="#description_bug_report">"Detailed Description of the Problem"</a></p>
</li>
<li>
<p><a href="#logs_traces_bug_report">"Logs and Traces"</a></p>
</li>
<li>
<p><a href="#troubleshooting_results">"Results from Troubleshooting Steps"</a></p>
</li>
</ul>
<a id="hardware_details" name="hardware_details"/>
<div>
<h3>Hardware Details</h3>
<p>Sometimes a bug arises or can be reproduced only on certain hardware configurations. If a fatal error occurs, the error log might contain the hardware details. If an error log is not available, document in the bug report the number and the type of processors in the machine, the clock speed, and, where applicable and if known, some details on the features of that processor. For example, in the case of Intel processors, it might be relevant that hyper-threading is available.</p>
</div>

<a id="operating_system" name="operating_system"/>
<div>
<h3>Operating System</h3>
<p>On the Solaris Operating System, the <code>showrev -a</code> command prints the operating system version and patch information.</p>
<p>On Linux, it is important to know which distribution and version is used. Sometimes the /etc/*release file indicates the release information, but as components and packages can be upgraded independently, it is not always a reliable indication of the configuration. Therefore, in addition to the information from the *release file, collect the following information:</p>
<ul>
<li>
<p>The kernel version. This can be obtained using the <code>uname -a</code> command.</p>
</li>
<li>
<p>The <code>glibc</code> version. The <code>rpm -q glibc</code> command indicates the patch level of <code>glibc</code>.</p>
</li>
<li>
<p>The thread library. There are two thread libraries for Linux, namely <code>LinuxThreads</code> and <code>NPTL</code>. The <code>LinuxThreads</code> library is used on 2.4 and older kernels and has "fixed stack" and "floating stack" variants. The Native POSIX Thread Library (<code>NPTL</code>) is used on the 2.6 kernel. Some Linux releases (such as RHEL3) include backports of <code>NPTL</code> to the 2.4 kernel. Use the command <code>getconf GNU_LIBPTHREAD_VERSION</code> to determine which thread library is used. If the <code>getconf</code> command returns an error to say that the variable does not exist, then it is likely that you are using an old kernel with the <code>LinuxThreads</code> library.</p>
</li>
</ul>
</div>

<a id="java_se_version_string" name="java_se_version_string"/>
<div>
<h3>Java SE Version</h3>
<p>The Java SE version string can be obtained using the <code>java -version</code> command.</p>
<p>Multiple versions of Java SE may be installed on the same machine. Therefore, ensure that you use the appropriate version of the <code>java</code> command by verifying that the installation bin directory appears in your <code>PATH</code> environment variable before other installations.</p>
</div>

<a id="command_line_bug_reports" name="command_line_bug_reports"/>
<div>
<h3>Command-Line Options</h3>
<p>If the bug report does not include a fatal error log, it is important to document the full command line and all its options. This includes any options that specify heap settings (for example, the <code>-mx</code> option) or any <code>-XX</code> options that specify HotSpot specific options.</p>
<p>One of the features in Java SE is garbage collector ergonomics. On server-class machines the <code>java</code> command launches the HotSpot Server VM and a parallel garbage collector. A machine is considered to be a server machine if it has at least two processors and 2GB or more of memory.</p>
<p>The <code>-XX:+PrintCommandLineFlags</code> option can be used to verify the command-line options. This option prints all command-line flags to the VM. The command-line options can also be obtained for a running VM or core file using the <code>jmap</code> utility.</p>
</div>

<a id="env_vars_bug_reports" name="env_vars_bug_reports"/>
<div>
<h3>Environment Variables</h3>
<p>Sometimes problems arise due to environment variable settings. When creating the bug report, indicate the values of the following Java environment variables (if set).</p>
<ul>
<li>
<p><code>JAVA_HOME</code></p>
</li>
<li>
<p><code>JRE_HOME</code></p>
</li>
<li>
<p><code>JAVA_TOOL_OPTIONS</code></p>
</li>
<li>
<p><code>_JAVA_OPTIONS</code></p>
</li>
<li>
<p><code>CLASSPATH</code></p>
</li>
<li>
<p><code>JAVA_COMPILER</code></p>
</li>
<li>
<p><code>PATH</code></p>
</li>
<li>
<p><code>USERNAME</code></p>
</li>
</ul>
<p>In addition, collect the following operating-system-specific environment variables.</p>
<ul>
<li>
<p>On Solaris OS and Linux, collect the values of the following environment variables.</p>
<ul>
<li>
<p><code>LD_LIBRARY_PATH</code></p>
</li>
<li>
<p><code>LD_PRELOAD</code></p>
</li>
<li>
<p><code>SHELL</code></p>
</li>
<li>
<p><code>DISPLAY</code></p>
</li>
<li>
<p><code>HOSTTYPE</code></p>
</li>
<li>
<p><code>OSTYPE</code></p>
</li>
<li>
<p><code>ARCH</code></p>
</li>
<li>
<p><code>MACHTYPE</code></p>
</li>
</ul>
</li>
<li>
<p>On Linux, also collect the values of the following environment variables.</p>
<ul>
<li>
<p><code>LD_ASSUME_KERNEL</code></p>
</li>
<li>
<p><code>_JAVA_SR_SIGNUM</code></p>
</li>
</ul>
</li>
<li>
<p>On Windows, collect the values of the following environment variables.</p>
<ul>
<li>
<p><code>OS</code></p>
</li>
<li>
<p><code>PROCESSOR_IDENTIFIER</code></p>
</li>
<li>
<p><code>_ALT_JAVA_HOME_DIR</code></p>
</li>
</ul>
</li>
</ul>
</div>

<a id="fatal_error_log_bug_report" name="fatal_error_log_bug_report"/>
<div>
<h3>Fatal Error Log</h3>
<p>When a fatal error occurs, an error log is created. For detailed information about this file, see <a href="felog.html#fatal_error_log_vm">"Fatal Error Log"</a>.</p>
<p>The error log contains much information obtained at the time of the fatal error, such as version and environment information, details on the threads that provoked the crash, and so forth.</p>
<p>If the fatal error log is generated, be sure to include it in the bug report or support call.</p>
</div>

<a id="core_crash_dump" name="core_crash_dump"/>
<div>
<h3>Core or Crash Dump</h3>
<p>Core and crash dumps can be very useful when trying to diagnose a system crash or hung process. The procedure for generating a dump is described in <a href="#collecting_core_dumps">"Collecting Core Dumps"</a>.</p>
</div>

<a id="description_bug_report" name="description_bug_report"/>
<div>
<h3>Detailed Description of the Problem</h3>
<p>When creating a problem description, try to include as much relevant information as possible. Describe the application, the environment, and most importantly the events leading up to the time when the problem was encountered.</p>
<ul>
<li>
<p>If the problem is reproducible, list the steps that are required to demonstrate the problem.</p>
</li>
<li>
<p>If the problem can be demonstrated with a small test case, include the test case and the commands to compile and execute the test case.</p>
</li>
<li>
<p>If the test case or problem requires third-party code (for example, a commercial or open source library or package), provide details on where and how to obtain the library.</p>
</li>
</ul>
<p>Sometimes the problem can be reproduced only in a complex application environment. In this case, the description, coupled with logs, core file, and other relevant information, might be the sole means to diagnose the issue. In these situations the description should indicate if the submitter is willing to run further diagnosis or run test binaries on the system where the issue arises.</p>
</div>

<a id="logs_traces_bug_report" name="logs_traces_bug_report"/>
<div>
<h3>Logs and Traces</h3>
<p>In some cases, log or trace output can help to quickly determine the cause of a problem.</p>
<p>For example, in the case of a performance issue the output of the <code>-verbose:gc</code> option can help in diagnosing the problem. (This is the option to enable output from the garbage collector.)</p>
<p>In other cases the output from the <code>jstat</code> command can be used to capture statistical information over the time period leading up to the problem.</p>
<p>In the case of a deadlock or a hung VM (for example, due to a loop) the thread stacks can help diagnose the problem. The thread stacks are obtained by pressing Control+\ on Solaris OS and Linux and Control+Break on Windows.</p>
<p>In general, include all relevant logs, traces and other output in the bug report or support call.</p>
</div>

<a id="troubleshooting_results" name="troubleshooting_results"/>
<div>
<h3>Results from Troubleshooting Steps</h3>
<p>Before submitting the bug report, be sure to document any troubleshooting steps that were performed.</p>
<p>For example, if the problem is a crash and the application has native libraries, you might have already run the application with the <code>-Xcheck:jni</code> option to reduce the likelihood that the bug is in the native code. Another case could be a crash that occurs with the HotSpot Server VM (<code>-server</code> option). If you have also tested with the HotSpot Client VM (<code>-client</code> option) and the problem does not occur, this gives an indication that the bug might be specific to the HotSpot Server VM.</p>
<p>In general, include in the bug report all troubleshooting steps and results that have already occurred. This type of information can often reduce the time that is required to diagnose an issue.</p>
</div>
</div>

<a id="collecting_core_dumps" name="collecting_core_dumps"/>
<div>
<h2>Collecting Core Dumps</h2>
<p>This section explains how to generate and collect core dumps (also known as crash dumps). A core dump or a crash dump is a memory snapshot of a running process. A core dump can be automatically created by the operating system when a fatal or unhandled error (for example, signal or system exception) occurs. Alternatively, a core dump can be forced by means of system-provided command-line utilities. Sometimes a core dump is useful when diagnosing a process that appears to be hung; the core dump may reveal information about the cause of the hang.</p>
<p>When collecting a core dump, be sure to gather other information about the environment so that the core file can be analyzed (for example, OS version, patch information, and the fatal error log).</p>
<p>Core dumps do not usually contain all the memory pages of the crashed or hung process. With each of the operating systems discussed here, the text (or code) pages of the process are not included in core dumps. But to be useful, a core dump must consist of pages of heap and stack as a minimum. Collecting non-truncated good core dump files is essential for postmortem analysis of the crash.</p>
<a id="core_dumps_solaris" name="core_dumps_solaris"/>
<div>
<h3>Collecting Core Dumps on Solaris OS</h3>
<p>With the Solaris Operating System, unhandled signals such as a segmentation violation, illegal instruction, and so forth, result in a core dump. By default, the core dump is created in the current working directory of the process and the name of the core dump file is core. The user can configure the location and name of the core dump using the core file administration utility, <code>coreadm</code>. This procedure is fully described in the man page for the <code>coreadm</code> utility.</p>
<p>The <code>ulimit</code> utility is used to get or set the limitations on the system resources available to the current shell and its descendants. Use the <code>ulimit -c</code> command to check or set the core file size limit. Make sure that the limit is set to <code>unlimited</code>; otherwise the core file could be truncated.</p>
<div align="center">
<div><br/>
<table border="1" cellpadding="3" cellspacing="0" frame="hsides" rules="groups" summary="" width="80%">
<tbody>
<tr>
<td align="left">
<p><b>Note:</b></p>
<p><code>ulimit</code> is a Bash shell built-in command; on a C shell, use the <code>limit</code> command.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
</div>
<p>Ensure that any scripts that are used to launch the VM or your application do not disable core dump creation.</p>
<p>The <code>gcore</code> utility can be used to get a core image of running processes. This utility accepts a process id (pid) of the process for which you want to force core dump.</p>
<p>To get the list of Java processes running on the machine, you can use any of the following commands:</p>
<ul>
<li>
<p><code>ps -ef | grep java</code></p>
</li>
<li>
<p><code>pgrep java</code></p>
</li>
<li>
<p><code>jps</code></p>
</li>
</ul>
<div align="center">
<div><br/>
<table border="1" cellpadding="3" cellspacing="0" frame="hsides" rules="groups" summary="" width="80%">
<tbody>
<tr>
<td align="left">
<p><b>Note:</b></p>
<p>The <code>jps</code> command-line utility does not perform name matching (that is, looking for "java" in the process command name) and so it can list Java VM embedded processes as well as the Java processes.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
</div>
<div><a id="sthref69" name="sthref69"/>
<h4>Using the <code>ShowMessageBoxOnError</code> Option on Solaris OS</h4>
<p>A Java process can be started with the <code>-XX:+ShowMessageBoxOnError</code> command-line option. When a fatal error is encountered, the process prints a message to standard error and waits for a <code>yes</code> or <code>no</code> response from standard input. Below is an example of output when an unexpected signal occurs.</p>
<pre xml:space="preserve">
=======================================================================
Unexpected Error
-----------------------------------------------------------------------
SIGSEGV (0xb) at pc=0xfeba31ac, pid=8677, tid=2
Do you want to debug the problem?
To debug, run 'dbx - 8677'; then switch to thread 2
Enter 'yes' to launch dbx automatically (PATH must include dbx)
Otherwise, press RETURN to abort...
=======================================================================
</pre>
<p>Before answering <code>yes</code> or pressing RETURN (Enter), use the <code>gcore</code> utility to force a core dump. Then you can type <code>yes</code> to launch the <code>dbx</code> debugger.</p>
</div>

<div><a id="sthref70" name="sthref70"/>
<h4>Suspending a Process using truss</h4>
<p>In situations where it is not possible to specify the <code>-XX:+ShowMessageBoxOnError</code> option, you might be able to use the <code>truss</code> utility. This Solaris OS utility is used to trace system calls and signals. You can use this utility to suspend the process when it reaches a specific function or system call.</p>
<p>The following command shows how to use the <code>truss</code> utility to suspend a process when the <code>exit</code> system call is executed (in other words, the process is about to exit).</p>
<pre xml:space="preserve">
$ truss -t \!all -s \!all -T exit -p pid
</pre>
<p>When the process calls <code>exit</code>, it will be suspended. At this point, you can attach the debugger to the process or call <code>gcore</code> to force a core dump.</p>
</div>
</div>

<a id="core_dumps_linux" name="core_dumps_linux"/>
<div>
<h3>Collecting Core Dumps on Linux</h3>
<p>On the Linux operating system, unhandled signals such as segmentation violation, illegal instruction, and so forth, result in a core dump. By default, the core dump is created in the current working directory of the process and the name of the core dump file is core.<span>pid</span>, where <span>pid</span> is the process id of the crashed Java process.</p>
<p>The <code>ulimit</code> utility is used to get or set the limitations on the system resources available to the current shell and its descendants. Use the <code>ulimit -c</code> command to check or set the core file size limit. Make sure that the limit is set to <code>unlimited</code>; otherwise the core file could be truncated.</p>
<div align="center">
<div><br/>
<table border="1" cellpadding="3" cellspacing="0" frame="hsides" rules="groups" summary="" width="80%">
<tbody>
<tr>
<td align="left">
<p><b>Note:</b></p>
<p><code>ulimit</code> is a Bash shell built-in command; on a C shell, use the <code>limit</code> command.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
</div>
<p>Ensure that any scripts that are used to launch the VM or your application do not disable core dump creation.</p>
<p>You can use the <code>gcore</code> command in the <code>gdb</code> (GNU Debugger) interface to get a core image of a running process. This utility accepts the pid of the process for which you want to force the core dump.</p>
<p>To get the list of Java processes running on the machine, you can use any of the following commands:</p>
<ul>
<li>
<p><code>ps -ef | grep java</code></p>
</li>
<li>
<p><code>pgrep java</code></p>
</li>
<li>
<p><code>jps</code></p>
</li>
</ul>
<div align="center">
<div><br/>
<table border="1" cellpadding="3" cellspacing="0" frame="hsides" rules="groups" summary="" width="80%">
<tbody>
<tr>
<td align="left">
<p><b>Note:</b></p>
<p>The <code>jps</code> command-line utility does not perform name matching (that is, looking for "java" in the process command name) and so it can list Java VM embedded processes as well as the Java processes.</p>
</td>
</tr>
</tbody>
</table>
<br/></div>
</div>
<div><a id="sthref71" name="sthref71"/>
<h4>Using the <code>ShowMessageBoxOnError</code> Option on Linux</h4>
<p>A Java process can be started with the <code>-XX:+ShowMessageBoxOnError</code> command-line option. When a fatal error is encountered, the process prints a message to standard error and waits for a <code>yes</code> or <code>no</code> response from standard input. Below is an example of output when an unexpected signal occurs.</p>
<pre xml:space="preserve">
=======================================================================
Unexpected Error
-----------------------------------------------------------------------
SIGSEGV (0xb) at pc=0x06232e5f, pid=11185, tid=8194
Do you want to debug the problem?
To debug, run 'gdb /proc/11185/exe 11185'; then switch to thread 8194
Enter 'yes' to launch gdb automatically (PATH must include gdb)
Otherwise, press RETURN to abort...
=======================================================================
</pre>
<p>Type <code>yes</code> to launch the <code>gdb</code> (GNU Debugger) interface, as suggested by the error report shown above. In the <code>gdb</code> prompt, you can give the <code>gcore</code> command. This command creates a core dump of the debugged process with the name core.<span>pid</span>, where <span>pid</span> is the process ID of the crashed process. Make sure that the <code>gdb gcore</code> command is supported in your versions of <code>gdb</code>. Look for <code>help gcore</code> in the <code>gdb</code> command prompt.</p>
</div>
</div>

<a id="no_core_file" name="no_core_file"/>
<div>
<h3>Reasons for Not Getting a Core File</h3>
<p>The following list explains the major reasons that a core file might not be generated. This list pertains to both Solaris OS and Linux, unless specified otherwise.</p>
<ul>
<li>
<p>The current user does not have permission to write in the current working directory of the process.</p>
</li>
<li>
<p>The current user has write permission on the current working directory, but there is already a file named core that has read-only permission.</p>
</li>
<li>
<p>The current directory does not have enough space or there is no space left.</p>
</li>
<li>
<p>The current directory has a subdirectory named core.</p>
</li>
<li>
<p>The current working directory is remote. It might be mapped by NFS (Network File System), and NFS failed just at the time the core dump was about to be created.</p>
</li>
<li>
<p>Solaris OS only: The <code>coreadm</code> tool has been used to configure the directory and name of the core file, but any of the above reasons apply for the configured directory or filename.</p>
</li>
<li>
<p>The core file size limit is too low. Check your core file limit using the <code>ulimit -c</code> command (Bash shell) or the <code>limit -c</code> command (C shell). If the output from this command is not unlimited, the core dump file size might not be large enough. If this is the case, you will get truncated core dumps or no core dump at all. In addition, ensure that any scripts that are used to launch the VM or your application do not disable core dump creation.</p>
</li>
<li>
<p>The process is running a <code>setuid</code> program and therefore the operating system will not dump core unless it is configured explicitly.</p>
</li>
<li>
<p>Java specific: If the process received <code>SIGSEGV</code> or <code>SIGILL</code> but no core dump, it is possible that the process handled it. For example, HotSpot VM uses the <code>SIGSEGV</code> signal for legitimate purposes, such as throwing <code>NullPointerException</code>, deoptimization, and so forth. The signal is unhandled by the Java VM only if the current instruction (PC) falls outside Java VM generated code. These are the only cases in which HotSpot dumps core.</p>
</li>
<li>
<p>Java specific: The JNI Invocation API was used to create the VM. The standard Java launcher was not used. The custom Java launcher program handled the signal by just consuming it and produced the log entry silently. This situation has occurred with certain Application Servers and Web Servers. These Java VM embedding programs transparently attempt to restart (fail over) the system after an abnormal termination. In this case, the fact that a core dump is not produced is a feature and not a bug.</p>
</li>
</ul>
</div>

<a id="BABFDGJB" name="BABFDGJB"/>
<div>
<h3>Collecting Crash Dumps on Windows</h3>
<p>On the Windows operating system there are three types of crash dumps:</p>
<ul>
<li>
<p>Dr. Watson logfile, which is a text error log file that includes faulting stack trace and a few other details.</p>
</li>
<li>
<p>User minidump, which can be considered a "partial" core dump. It is not a complete core dump, because it does not contain all the useful memory pages of the process.</p>
</li>
<li>
<p>Dr. Watson full-dump, which is equivalent to a Unix core dump. This dump contains most memory pages of the process (except for code pages).</p>
</li>
</ul>
<p>When an unexpected exception occurs on Windows, the action taken depends on two values in the following registry key:</p>
<pre xml:space="preserve">
\\HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\AeDebug
</pre>
<p>The two values are named <code>Debugger</code> and <code>Auto</code>. The <code>Auto</code> value indicates if the debugger specified in the value of the <code>Debugger</code> entry starts automatically when an application error occurs.</p>
<ul>
<li>
<p>A value of <code>0</code> for <code>Auto</code> means that the system displays a message box notifying the user when an application error occurs.</p>
</li>
<li>
<p>A value of <code>1</code> for <code>Auto</code> means that the debugger starts automatically.</p>
</li>
</ul>
<p>The value of <code>Debugger</code> is the debugger command that is to be used to debug program errors.</p>
<p>When a program error occurs, Windows examines the <code>Auto</code> value and if the value is <code>0</code> it executes the command in the <code>Debugger</code> value. If the value for <code>Debugger</code> is a valid command, a message box is created with two buttons: <b>OK</b> and <b>Cancel</b>. If the user clicks <b>OK</b>, the program is terminated. If the user clicks <b>Cancel</b>, the specified debugger is started. If the value for the <code>Auto</code> entry is set to <code>1</code> and the value for the <code>Debugger</code> entry specifies the command for a valid debugger, the system automatically starts the debugger and does not generate a message box.</p>
<div><a id="sthref72" name="sthref72"/>
<h4>Configuring Dr. Watson</h4>
<p>The Dr. Watson debugger is used to create crash dump files. By default, the Dr. Watson debugger (drwtsn32.exe) is installed into the Windows system folder (<span>%SystemRoot%</span>\System32).</p>
<p>To install Dr. Watson as the postmortem debugger, run the following command:</p>
<pre xml:space="preserve">
drwtsn32 -i
</pre>
<p>To configure name and location of crash dump files, run <code>drwtsn32</code> without any options.</p>
<p>In the Dr. Watson GUI window, make sure that the <b>Create Crash Dump File</b> check box is selected and that the crash dump file path and log file path are configured in their respective text fields.</p>
<p>Dr. Watson may be configured to create a full dump using the registry. The registry key is as follows:</p>
<pre xml:space="preserve">
System Key: [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\DrWatson]
Entry Name: CreateCrashDump
Value: (0 = disabled, 1 = enabled)
</pre>
<p>Note that if the application handles the exception, then the registry-configured debugger is not invoked. In that case it might be appropriate to use the <code>-XX:+ShowMessageBoxOnError</code> command-line option to force the process to wait for user intervention on fatal error conditions.</p>
</div>

<div><a id="sthref73" name="sthref73"/>
<h4>Forcing a Crash Dump</h4>
<p>On the Windows operating system, the <code>userdump</code> command-line utility can be used to force a Dr. Watson dump of a running process. The <code>userdump</code> utility does not ship with Windows but instead is released as a component of the OEM Support Tools package.</p>
<p>An alternative way to force a crash dump is to use the <code>windbg</code> debugger. The main advantage of using <code>windbg</code> is that it can attach to a process in a non-invasive manner (that is, read-only). Normally Windows terminates a process after a crash dump is obtained but with the non-invasive attach it is possible to obtain a crash dump and let the process continue. To attach the debugger non-invasively requires selecting the <b>Attach to Process</b> option and the <b>Noninvasive</b> checkbox.</p>
<p>When the debugger is attached, a crash dump can be obtained using the following command.</p>
<pre xml:space="preserve">
.dump /f crash.dmp
</pre>
<p>The <code>windbg</code> debugger is included in the "Debugging Tools for Windows" download.</p>
<p>An additional utility in this download is the <code>dumpchk.exe</code> utility, which can verify that a memory dump file has been created correctly.</p>
<p>Both <code>userdump.exe</code> and <code>windbg</code> require the pid of the process. The <code>userdump -p</code> command lists the process and program for all processes. This is useful if you know that the application is started with the <code>java.exe</code> launcher. However, if a custom launcher is used (embedded VM), it might be difficult to recognize the process. In that case you can use the <code>jps</code> command-line utility as it lists the pids of the Java processes only.</p>
<p>As with Solaris OS and Linux, you can also use the <code>-XX:+ShowMessageBoxOnError</code> command-line option on Windows. When a fatal error is encountered, the process shows a message box and waits for a <code>yes</code> or <code>no</code> response from the user.</p>
<p>Before clicking <b>Yes</b> or <b>No</b>, you can use the <code>userdump.exe</code> utility to generate the Dr. Watson dump for the Java process. This utility can also be used in cases when the process appears to be hung.</p>
</div>
</div>
</div>
<a href="toc.html">
                Contents</a>&nbsp;&nbsp;&nbsp;<a href="signals.html">
                Previous</a>&nbsp;&nbsp;&nbsp;<a href="envvars.html">
                Next</a><hr/>





<!--  footer start -->
<div id="javasefooter">
<div class="hr">
<hr /></div>
<div id="javasecopyright">
<img id="oraclelogofooter" src=
"../../../images/oraclelogo.gif" alt="Oracle and/or its affiliates"
border="0" width="100" height="29" name=
"oraclelogofooter" />

<a href="../../../legal/cpyr.html">Copyright
&#169;</a> 1993, 2014, Oracle and/or its affiliates. All rights
reserved.</div>
<div id="javasecontactus">
<a href=
"http://docs.oracle.com/javase/feedback.html">Contact
Us</a>
</div>
</div>
<!-- footer end -->

<!-- STATIC FOOTER -->

</body>
</html>
